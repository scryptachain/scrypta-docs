# Progressive Data Management
Through these methods it is possible to write, update and invalidate data within the blockchain.

## write(password, metadata, collection = '', refID = '', protocol = '', key = '', uuid = '')

It allows you to write an indefinite amount of data within your address. These data will be processed by IdANodes and can be read by invoking APIs.

Here are the parameters that can be set:

-   **password:** the password to decrypt the identity payload.
    
-   **metadata:** the data to be written, in the form of a string. There is no character limit as multiple transactions are chained. Greater length means greater expenditure of LYRA. It should be emphasized, of course, that chaining a large number of transactions is not recommended as the failure of a single transaction would invalidate the entire data.
    
-   **collection:** a parameter that allows you to catalog data within a collection. Useful for structuring data, this parameter can be used as a filter when reading data from IdANodes.
    
-   **refID:** a parameter that allows you to give a single reference to the data, a sort of additional ID that you can filter, always from the IdANodes.
    
-   **protocol:**it is another type of filter, it is used to define the protocols and therefore the type of data entered. For example, Scrypta used the ** E: // ** protocols for encrypted data, **I: //** for identity, etc. There is no constraint of any kind in using protocols.
    
-   **key:** the identity payload to use; if omitted, the localStorage one is used.
    
- **uuid:** a possible uuid to write sequentially on the same data.

The method will return an object containing a series of information:

-   **uuid:**the unique identifier (uuid / v4) generated by the IdANode to identify the specific data or that passed in the method.
    
-   **address:** the address where the information was written.
    
-   **fees:** the total amount of fees used.
    
-   **collection / refID / protocol:** the parameters passed previously.
    
-   **dimension:** the final size of the entered data.
    
-   **chunks:** the amount of concatenated transactions.
    
-   **stored:** the raw data that was actually written in blockchain.
    
-   **txs:** the txid of the transactions actually sent.
    
Here is an example:
```
{

 "uuid":"9022b33e.a4e8.401e.b32b.a2b75b012554",

 "address":"LLLjx7yV4nhUzSapBAHogb5BdgUR6VCB3o",

 "fees":0.010000000000000002,

 "collection":"",

 "refID":"",

 "protocol":"",

 "dimension":702,

 "chunks":10,

 "stored":"*!*9022b33e.a4e8.401e.b32b.a2b75b012554!*!!*!!*!*=>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis quis risus auctor, eleifend neque sit amet, ultricies nulla. Suspendisse condimentum nisi ut nunc mattis, vel congue velit congue. Aliquam sit amet pharetra tellus. Etiam tellus lacus, pretium vel commodo a, tempor nec ante. Aenean turpis nisi, pulvinar eget vehicula at, dapibus at dui. Cras vitae dictum massa. Sed in orci lorem. Nullam ut mattis lacus. Mauris ut mattis tellus. Donec et posuere lorem, id elementum ligula. Aliquam eu mollis neque, eget venenatis erat. Aenean vestibulum nunc diam, et luctus massa porttitor ac. Morbi tempor eleifend bibendum. Curabitur sed diam leo.*!*",

 "txs":["2432e4f57d355122d6c55331593ac3fc1c0095b2c9bcd7ba7c6e65fcf4cf07c7","c6d592889105c2989c43df50197f3b0d35449497001be69842602b9a72306a03","cf52acfc5384813ea65741354066962e10c33db826e575d300326850f0761c7f","b3d38ee224f8f82bbf0c4f878740dea5664ce3b90c2f5fea38e53ee1caa3a5d8","915ff12007dc738761c4746087fca2d03c17cefb272504d04f3378d3038816d1","76e3d9427575a82550e3461dad453d006c1d79bb59fd64eadcd6ce2f884ca582","d7650a8357fe031eec3672210c4d96bc41383375eeeac87062efb7c273daf924","27a00bc5478d6e50e04375271066c6ad7e0ac923d5553ab41358643942baf859","bedec596bf4117cea73095ec32361aef2425a65b9f1be23fd842181552c7d00e","6b4959c76eb57e3e913965901bf627f3e82e6c1332ae34d571f1222c68a24d49"]

}
```

This same information can be retrieved and filtered by the IdANode. The example can be consulted at the following link: [https://proof.scryptachain.org/#/uuid/2b33e.a4e8.401e.b32b.a2b75b012554](https://proof.scryptachain.org/#/uuid/2b33e.a4e8.401e.b32b.a2b75b012554)​

Here is the example that produced the result just described:
```
const scrypta = new ScryptaCore

var metadata =  'Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis quis risus auctor, eleifend neque sit amet, ultricies nulla. Suspendisse condimentum nisi ut nunc mattis, vel congue velit congue. Aliquam sit amet pharetra tellus. Etiam tellus lacus, pretium vel commodo a, tempor nec ante. Aenean turpis nisi, pulvinar eget vehicula at, dapibus at dui. Cras vitae dictum massa. Sed in orci lorem. Nullam ut mattis lacus. Mauris ut mattis tellus. Donec et posuere lorem, id elementum ligula. Aliquam eu mollis neque, eget venenatis erat. Aenean vestibulum nunc diam, et luctus massa porttitor ac. Morbi tempor eleifend bibendum. Curabitur sed diam leo.'

var password =  'AStrongPassword'

var collection =  ''

var refID =  ''

var protocol =  ''

​let written =  await scrypta.write(password, metadata, collection, refID, protocol)
```

## update(password, metadata, collection = '', refID = '', protocol = '', key = '', uuid)

This method recalls the precedent of which it is an alias. In this case, however, the uuid field is mandatory, useful to verify that a given duplication is not actually created.

It should be noted that the update of data present in blockchain **is not** an overwriting, all transactions are **immutable**. In fact, the operation that is carried out is that of sequential updating of the data. In case of updated data, the IdANode will always return the last one even if the history can be recovered by passing the parameter _history = **true** _ during the reading phase.

## invalidate(password, key  =  '', uuid)

Like the previous method, this method calls the write operation. In this case the written data is always composed of the **UUID** and the information **END**. This will be interpreted by the IdANode as a data not to be ** shown during the reading phase. As already specified, however, the **non** information can be deleted from the blockchain and can be recovered by the IdANodes themselves by passing the parameter _history = **true** _ during the reading phase.
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTE1MTc4MjkwOF19
-->